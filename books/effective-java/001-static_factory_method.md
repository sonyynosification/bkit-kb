# Xem xét sử dụng static factory method thay cho constructor
Phương pháp truyền thống để tạo ra được một instance là cung cấp một public constructor để cho người khác có thể sử dụng. Ngoài ra thì mỗi programmer cũng nên biết một kỹ thuật khác. Class có thể cung cấp một *public static factory method*, hiểu đơn giản là một *static method* trả về một instance của chính class đó.  
Hãy cùng quan sát ví dụ dưới đây của class Boolean:

```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

Lưu ý một điều rằng `static factory method` được đề cập ở đây thì không có tương đương với `Factory Method` pattern được nhắc đến trong `Design Patterns`(1).  
Một class có thể cung cấp `static factory method` cùng với hoặc không cùng với public constructors. Việc sử dụng một `static factory method` thay vì public constructor đều có những ưu nhược điểm của nó.  
**Ưu điểm đầu tiên của static factory method so với public constructor là chúng sẽ được đặt tên**. Trong trường hợp mà các tham số của constructor không thể hiện một cách tường minh object được tạo ra, thì sử dụng static factory method có tên được đặt một cách có ý nghĩa, sẽ giúp người code và người đọc code có thể hiểu một cách dễ dàng hơn. Ví dụ ta có constructor của class `BigInteger(int, int, Random)`, trả về một số `BigInteger` có thể là số nguyên tố. Trường hợp này tốt hơn nếu như chúng ta sử dụng static factory method: `BigInteger.probablyPrime` (đã được thêm vào từ Java 4).  
Trong mỗi class thì đối với 1 signature nhất định, chỉ có thể khai báo 1 constructor tương ứng. Một số programmer đã tìm cách luồn lách quy tắc này bằng cách tạo ra 2 constructor giống nhau, chỉ khác nhau về thứ tự tham số đầu vào. Làm như thế này thì rất là tệ vì người code sẽ không bao giờ nhớ được là nên gọi constructor nào, và trước sau gì cũng sễ gọi nhầm constructor. Ai mà đọc code thì cũng sẽ ko hiểu được tác dụng của nó trừ khi nhìn vào documentation.  
Nhờ vào việc được đặt tên rõ ràng nên *static factory method* sẽ tránh được những hạn chế của constructor đã nói ở trên. Nếu chúng ta cần phải có nhiều constructor có cùng signature, thì việc sử dụng static factory method sẽ là tốt nhất.  
**Ưu điểm thứ hai của static factory method là việc nó sẽ không nhất thiết phải tạo ra object mới mỗi khi được gọi**. Điều này sẽ giúp chúng ta tạo ra được các immutable class bằng cách sử dụng các instance có sẵn, hoặc cache instance sau khi chúng được tạo ra, tránh việc tạo ra các instance giống nhau không cần thiết. Method `Boolean.valueOf(boolean)` đã đề cập ở trên minh họa rõ kỹ thuật này, có thể thấy nó không bao giờ tạo ra object mới!. Phương thức này cũng tương tự như *Flyweight Pattern*. Sử dụng nó giúp cho chúng ta tăng performance chương trình khi object này được tạo ra thường xuyên, đặc biệt nếu như việc khởi tạo object này trở nên tốn kém.  
Ngoài ra việc có thể trả về cùng một object trong nhiều lần gọi khác nhau giúp class có thể kiểm soát được việc bao nhiêu instance có thể xuất hiện tại một thời điểm. Những class làm được điều này sẽ được gọi là *instance controlled*. Có vài lý do để viết ra các *instance controlled* class. Nó giúp một class đảm bảo một vài tính chất như *singleton* hoặc *noninstantiable* (không được phép tạo mới). Đồng thời nó cũng đảm bảo rằng không có 2 instances equal nhau xuất hiện đồng thời: `a.equals(b) <=> a == b`. Đây là quy tắc cơ bản của *Flyweight pattern*. Tiêu biểu có thể kể đến Enum.  
**Ưu điểm thử 3 của static factory method là việc không giống như constructor, nó có thể trả về subtype của object được khởi tạo**. Điều này hỗ trợ rất tốt cho việc lựa chọn return type một cách linh động.  
Một ứng dụng của tính chất này chính là việc một API có thể return object nhưng ko cần phải biến được trả về đó thành public. Việc giấu đi implementation của class này giúp tạo ra một API rất ngắn gọn. Điều này giúp tạo ra các *interface-based* frameworks.  
Trước Java 8 thì interface sẽ không có static method. Theo convention thì static factory method cho interface `Type` thường sẽ được đặt trong 1 *noninstantiable class* là `Types`. Ví dụ như Java Collections Framework có 45 utility implementations khác nhau cho các interfaces, ví dụ như *unmodifiable collections* (không thể thay đổi) hoặc *synchronized collections*. Hầu như tất cả implementation này đều đến từ static factory method trong `java.util.Collections` class, và class này thì *noninstantiable* (không tạo mới được). Các class được trả về đều không được public.  
Nếu mà Collections Framework đều cho 45 implementation class này ra một public class, và mỗi class tạo ra một phương thức khởi tạo riêng thì Collections API sẽ không nhỏ gọn như hiện tại. Không những về kích thước của API, mà nó còn giảm thiểu khối lượng về mặt concept mà developer phải nắm được để sử dụng API đó. Nhờ có API interface define rõ ràng nên developer sẽ không cần phải đọc documentation để nắm được tác dụng của từng implementation class. Hơn nữa việc sử dụng static factory method sẽ bắt bưộc người code sử dụng interface class thay vì implementation class, và đó là good practice.  
Với việc Java 8 hỗ trợ static method cho interface thì cũng không có lý do gì mà phải sử dụng companion class cho một interface nữa. Các public static method trong class cũng có thể được chuyển về interfafce. Tuy nhiên hãy lưu ý rằng việc đưa các implementation phức tạp vào các class private thì vẫn rất cần thiết, thay vì để hết trong interface. Lý do là vì static method trong Java 8 bắt buộc phải public. Từ Java 9, thì sẽ hỗ trợ private static method trong interface, nhưng mà static fields / inner class thì vẫn buộc phải public.   
**Ưu điểm thứ 4 là việc class của return object có thể thay đổi tùy theo tham số đầu vào**.  
Class `EnumSet` không có constructor, mà chỉ có static factory method. OpenJDK sẽ trả về một trong hai loại subclass tùy theo kích thước của Enum truyền vào: nếu enum có ít hơn hoặc bằng 64 phần tử, thì factory method sẽ trả về một `RegularEnumSet`, sử dụng một biến `long` thao tác. Ngược lại thì method này sẽ trả về `JumboEnumSet`, sử dụng long array.  
Đối với người sử dụng thì chúng ta sẽ không biết được sự tồn tại của 2 cách implement này. Nếu `RegularEnumSet` không có tăng được performance cho các loại enum có ít phần tử thì nó có thể được remove trong tương lai một cách an toàn. Tương tự như vậy, trong tương lai chúng ta có thể thêm vào các implement thứ 3,4 của `EnumSet` nếu nó có performance tốt hơn. Người sử dụng không cần quan tâm những subclass này làm gì, họ chỉ cần biết là đang làm việc với `EnumSet` thôi là đủ.  
**Ưu điểm thứ 5 của static factory method là việc class của object trả về không cần phải tồn tại khi class chứa method này được viết**. Sự linh hoạt này là cơ sở cho các *service provider framework*, như JDBC hoạt động hiệu quả. Một *service provider* là một hệ thống mà *providers* sẽ implement một service, còn hệ thống sẽ cung cấp các implementations này cho clients, tách biệt giữa client và implementation.(2)  
